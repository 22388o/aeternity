// This smart contract is an example contract for staking
// It does not allow delegated staking
// It is intended to be used in a PoS context
include "List.aes"
contract Staking =

  type staker = address 
  type balance = int
  type staker_pool = map(staker, balance)

  record state = { online_stakers   : staker_pool,
                   offline_stakers  : staker_pool, 
                   total_stake      : balance,
                   entropy          : hash,
                   leader           : staker
                    }

  entrypoint init(initial_stakers: staker_pool, entropy_string : string) : state =
    { online_stakers  = initial_stakers,
      offline_stakers = {},
      entropy         = Crypto.sha256(entropy_string),
      leader          = Contract.address,
      total_stake     = sum_staker_amounts(initial_stakers)
      }

  stateful payable entrypoint stake() =
    let sender = Call.origin
    let old_balance = Map.lookup_default(sender, state.online_stakers, 0)
    add_stake(Call.origin, Call.value)

  stateful entrypoint unstake(amount : int) =
    let unstaker = Call.origin
    remove_stake(unstaker, amount)

  stateful entrypoint elect() =
    let new_leader = elect_at_height(Chain.block_height)
    put(state{ leader = new_leader})

  stateful payable entrypoint reward_fees(who : address) =
    add_stake(who, Call.value)

  entrypoint elect_next() =
    elect_at_height(Chain.block_height + 1)

  entrypoint leader() =
    state.leader

  entrypoint balance(who) =
    switch(Map.lookup(who, state.online_stakers))
      None => abort("unknown_address")
      Some(balance) => balance

  function elect_at_height(height : int) =
    let sorted = List.sort(cmp, Map.to_list(state.online_stakers))
    let shot = Bytes.to_int(state.entropy) * height mod state.total_stake
    switch(find_staker(sorted, shot))
      None => abort("NO_CANDIDATE") // should not be possible
      Some(new_leader) => new_leader

  function find_staker(stakers, shot) =
    switch(stakers)
      []   => None
      (winning_staker, stake)::t =>
        if(stake > shot) Some(winning_staker)
        else find_staker(t, shot - stake)        

  function cmp((x, x_amt), (y, y_amt)) =
    if (x_amt == y_amt) x < y else x_amt < y_amt 

  function tuple_second_element((k, v)) = v

  function list_pop_last(list) =
    switch(List.reverse(list))
      [] => abort("pop_empty_list")
      last :: tail =>
        (last, List.reverse(tail))

  function sum_staker_amounts(stakers : staker_pool) =
    List.sum(List.map(tuple_second_element, Map.to_list(stakers)))

  function is_online(staker : address) : bool = 
    Map.member(staker, state.online_stakers)

  stateful function add_stake(receiver : staker, bal : balance) =
    switch(is_online(receiver))
      true =>
        let Some(old_balance) = Map.lookup(receiver, state.online_stakers)
        put(state{online_stakers[receiver] = old_balance + bal,
            total_stake = state.total_stake + bal})
      false =>
        let old_balance = Map.lookup_default(receiver, state.offline_stakers, 0)
        put(state{offline_stakers[receiver] = old_balance + bal})

  stateful function remove_stake(from : staker, amount: balance)  =
    switch(is_online(from))
      true =>
        put(state{online_stakers = remove_stake_(from, amount, state.online_stakers),
                  total_stake = state.total_stake - amount })
      false =>
        put(state{offline_stakers = remove_stake_(from, amount, state.offline_stakers)})

  stateful function remove_stake_(from : staker, amount: balance, pool : staker_pool) : staker_pool =
    let old_balance = Map.lookup_default(from, pool, 0)
    require(old_balance >= amount, "not_enough_coins")
    Chain.spend(from, amount)
    if (old_balance - amount == 0)
      Map.delete(from, pool)
    else
      pool{ [from] = old_balance - amount } 
